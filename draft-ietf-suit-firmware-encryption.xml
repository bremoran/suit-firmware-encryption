<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- generated by https://github.com/cabo/kramdown-rfc version 1.6.35 (Ruby 3.0.2) -->
<?rfc rfcedstyle="yes"?>
<?rfc tocindent="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>
<?rfc toc_levels="4"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-ietf-suit-firmware-encryption-13" category="std" consensus="true" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 3.17.4 -->
  <front>
    <title abbrev="Encrypted Payloads in SUIT Manifests">Encrypted Payloads in SUIT Manifests</title>
    <seriesInfo name="Internet-Draft" value="draft-ietf-suit-firmware-encryption-13"/>
    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization/>
      <address>
        <email>hannes.tschofenig@gmx.net</email>
      </address>
    </author>
    <author initials="R." surname="Housley" fullname="Russ Housley">
      <organization abbrev="Vigil Security">Vigil Security, LLC</organization>
      <address>
        <email>housley@vigilsec.com</email>
      </address>
    </author>
    <author initials="B." surname="Moran" fullname="Brendan Moran">
      <organization>Arm Limited</organization>
      <address>
        <email>Brendan.Moran@arm.com</email>
      </address>
    </author>
    <author initials="D." surname="Brown" fullname="David Brown">
      <organization>Linaro</organization>
      <address>
        <email>david.brown@linaro.org</email>
      </address>
    </author>
    <author initials="K." surname="Takayama" fullname="Ken Takayama">
      <organization>SECOM CO., LTD.</organization>
      <address>
        <email>ken.takayama.ietf@gmail.com</email>
      </address>
    </author>
    <date year="2023" month="July" day="06"/>
    <area>Security</area>
    <workgroup>SUIT</workgroup>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <?line 87?>

<t>This document specifies techniques for encrypting software, firmware
and personalization data by utilizing the IETF
SUIT manifest. Key agreement is provided by ephemeral-static (ES)
Diffie-Hellman (DH) and AES Key Wrap (AES-KW). ES-DH
uses public key cryptography while AES-KW uses a pre-shared
key-encryption key. Encryption of the plaintext is
accomplished with conventional symmetric key cryptography.</t>
    </abstract>
  </front>
  <middle>
    <?line 97?>

<section anchor="introduction">
      <name>Introduction</name>
      <t>Vulnerabilities with Internet of Things (IoT) devices have raised the
need for a reliable and secure firmware update mechanism that is also
suitable for constrained devices. To protect firmware images the SUIT manifest
format was developed <xref target="I-D.ietf-suit-manifest"/>. The SUIT manifest provides a
bundle of metadata about the firmware for an IoT device, where to find 
the firmware image, and the devices to which it applies.</t>
      <t>The SUIT information model <xref target="RFC9124"/> details the
information that has to be offered by the SUIT manifest format. In addition to
offering protection against modification, which is provided by a digital
signature or a message authentication code, the firmware image may also
be afforded confidentiality using encryption.</t>
      <t>Encryption prevents third parties, including attackers, from gaining access to
the firmware binary. Hackers typically need intimate knowledge of the target
firmware to mount their attacks. For example, return-oriented programming (ROP)
<xref target="ROP"/> requires access to the binary and encryption makes it much more difficult
to write exploits.</t>
      <t>The SUIT manifest provides the data needed for authorized recipients
of the firmware image to decrypt it. The firmware image is encrypted using a
symmetric key.</t>
      <t>A symmetric key can be established using a variety of mechanisms; this document
defines two approaches for use with the IETF SUIT manifest, namely:</t>
      <ul spacing="normal">
        <li>Ephemeral-Static (ES) Diffie-Hellman (DH), and</li>
        <li>AES Key Wrap (AES-KW) using a pre-shared key-encryption key (KEK).</li>
      </ul>
      <t>OPEN ISSUE: Should KEM algorithms also be supported?</t>
      <t>These choices reduce the number of possible key establishment options and thereby
help increase interoperability between different SUIT manifest parser implementations.</t>
      <t>While the original motivating use case of this document was firmware encryption, SUIT manifests
may require payloads other than firmware images to experience confidentiality
protection, such as</t>
      <ul spacing="normal">
        <li>software packages,</li>
        <li>personalization data,</li>
        <li>configuration data, and</li>
        <li>machine learning models.</li>
      </ul>
      <t>Hence, the term payload is used to generically refer to those objects that may be subject to
encryption.</t>
    </section>
    <section anchor="conventions-and-terminology">
      <name>Conventions and Terminology</name>
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in BCPÂ 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
when, and only when, they appear in all capitals, as shown here.</t>
      <t>This document assumes familiarity with the IETF SUIT manifest <xref target="I-D.ietf-suit-manifest"/>,
the SUIT information model <xref target="RFC9124"/> and the SUIT architecture <xref target="RFC9019"/>.</t>
      <t>The terms sender and recipient have the following meaning:</t>
      <ul spacing="normal">
        <li>Sender: Role of the entity that sends an encrypted payload.</li>
        <li>Recipient: Role of the entity that receives an encrypted payload.</li>
      </ul>
      <t>Additionally, the following abbreviations are used in this document:</t>
      <ul spacing="normal">
        <li>Key Wrap (KW), defined in <xref target="RFC3394"/> (for use with AES)</li>
        <li>Key-Encryption Key (KEK) <xref target="RFC3394"/></li>
        <li>Content-Encryption Key (CEK) <xref target="RFC5652"/></li>
        <li>Ephemeral-Static (ES) Diffie-Hellman (DH) <xref target="RFC9052"/></li>
      </ul>
    </section>
    <section anchor="arch">
      <name>Architecture</name>
      <t><xref target="RFC9019"/> describes the architecture for distributing payloads and
manifests from an author to devices. It does, however, not detail the
use of payload encryption.</t>
      <t>This document enhances this architecture to support encryption. The author
and the distribution system are logical roles. In some deployments these
roles are separated in different physical entities and in others they are
co-located.</t>
      <t><xref target="arch-fig"/> shows the distribution system, which represents the firmware
server and the device management infrastructure. The distribution system is
aware of the individual devices to which a payload has to be delivered. The
author is typically unaware which devices need to receive these payloads.</t>
      <t>To apply encryption the sender needs to know the recipient. For AES-KW the
KEK needs to be known and, in case of ES-DH, the sender needs to be in possession
of the public key of the recipient. The DH public key and parameters may be in
the recipient's X.509 certificate <xref target="RFC5280"/>.</t>
      <t>If the author delegates the task of identifying the recipients of the payloads
to the distribution system, it needs to trust it with the appropriate
protection of the plaintext firmware image before encryption is performed.</t>
      <figure anchor="arch-fig">
        <name>Firmware Encryption Architecture.</name>
        <artwork><![CDATA[
                                           +----------+
                                           |          |
                                           |  Author  |
                                           |          |
 +----------+                              +----------+
 |  Device  |---+                               |
 |          |   |                               | Firmware +
 |          |   |                               | Manifest
 +----------+   |                               |
                |                               |
                |                        +--------------+
                |                        |              |
 +----------+   |  Firmware + Manifest   | Distribution |
 |  Device  |---+------------------------|    System    |
 |          |   |                        |              |
 |          |   |                        |              |
 +----------+   |                        +--------------+
                |
                |
 +----------+   |
 |  Device  +---+
 |          |
 |          |
 +----------+
]]></artwork>
      </figure>
      <t>To offer confidentiality protection two deployment variants need to be
supported:</t>
      <ul spacing="normal">
        <li>The author, as the sender, transmits the encrypted payload to a single
device, or to multiple devices. The device(s) perform decryption and
act as recipients.</li>
        <li>The author treats the distribution system as the initial recipient. Then,
the distribution system decrypts and re-encrypts the payload for consumption
by the device (or the devices). Delegating the task of re-encrypting
the payload to the distribution system offers flexiblity when the number
of devices that need to receive encrypted payloads changes dynamically
or when updates to KEKs or recipient public keys are necessary. As a downside,
the author needs to trust the distribution system with performing the
re-encryption of the payload.</li>
      </ul>
      <t>For both variants the key distribution data, which is embedded inside the
COSE_Encrypt structure, is included in the SUIT manifest.</t>
    </section>
    <section anchor="parameters">
      <name>Encryption Extensions</name>
      <t>This specification introduces a new extension to the SUIT_Parameters structure.</t>
      <t>The SUIT encryption info parameter (called suit-parameter-encryption-info),
see <xref target="parameter-fig"/>, contains key distribution information. It is carried
inside the suit-directive-override-parameters or the suit-directive-set-parameters
structure. The content of the SUIT_Encryption_Info structure is explained in
<xref target="AES-KW"/> (for AES-KW) and <xref target="ES-DH"/> (for ECDH-ES). An implementation claiming
conformance with this specification must implement support for this parameter.
A device may, however, support only one of the available key distribution techniques.</t>
      <figure anchor="parameter-fig">
        <name>CDDL of the SUIT_Parameters Extension.</name>
        <artwork><![CDATA[
SUIT_Parameters //= (suit-parameter-encryption-info
    => bstr .cbor SUIT_Encryption_Info)

suit-parameter-encryption-info   = [TBD1: Proposed 19]
]]></artwork>
      </figure>
    </section>
    <section anchor="extended-directives">
      <name>Extended Directives</name>
      <t>This specification extends these directives:</t>
      <ul spacing="normal">
        <li>Directive Write (suit-directive-write) to decrypt the content specified by
suit-parameter-content with suit-parameter-encryption-info.</li>
        <li>Directive Copy (suit-directive-copy) to decrypt the content of the component
specified by suit-parameter-source-component with suit-parameter-encryption-info.</li>
      </ul>
      <t>Examples of the two extensioned directives are shown in <xref target="encryption-info-consumed-with-write"/>
and in <xref target="encryption-info-consumed-with-copy"/>.</t>
      <figure anchor="encryption-info-consumed-with-write">
        <name>Example showing the Extended suit-directive-write.</name>
        <artwork><![CDATA[
/ directive-override-parameters / 20, {
  / parameter-content / 18: h'EA1CED',
  / parameter-encryption-info / 19: h'D860E1A1F0'
},
/ directive-write / 18, 15
/ NOTE: decrypt h'EA1CED' using h'D860E1A1F0' /
/ NOTE: plaintext payload is stored into component #0 /
]]></artwork>
      </figure>
      <figure anchor="encryption-info-consumed-with-copy">
        <name>Example showing the Extended suit-directive-copy.</name>
        <artwork><![CDATA[
/ directive-set-component-index / 12, 1,
/ directive-override-parameters / 20, {
  / parameter-uri / 21: "http://example.com/encrypted.bin",
},
/ directive-fetch / 21, 15,
/ NOTE: encrypted payload is stored into component #1 /
/ directive-set-component-index / 12, 0,
/ directive-override-parameters / 20, {
  / parameter-source-component / 22: 1,
  / parameter-encryption-info / 19: h'D860E1A1F0'
},
/ directive-copy / 22, 15
/ NOTE: decrypt component #1 using h'D860E1A1F0' /
/ NOTE: plaintext payload is stored into component #0 /
]]></artwork>
      </figure>
    </section>
    <section anchor="content-key-distribution-methods">
      <name>Content Key Distribution Methods</name>
      <t>The sub-sections below describe two content key distribution mechanisms,
namely AES Key Wrap (AES-KW) and Ephemeral-Static Diffie-Hellman (ES-DH).
Other mechanisms are supported by COSE and may be supported via enhancements
to this specification.</t>
      <t>When an encrypted firmware image is sent to multiple recipients, there
are different deployment options. To explain these options we use the
following notation:</t>
      <ul spacing="normal">
        <li>KEK(R1,S) refers to a KEK shared between recipient R1 and the sender S.
The KEK, as a concept, is used by AES Key Wrap.</li>
        <li>CEK(R1,S) refers to a CEK shared between R1 and S.</li>
        <li>CEK(<em>,S) or KEK(</em>,S) are used when a single CEK or a single KEK is shared
with all authorized recipients by a given sender S in a certain context.</li>
        <li>ENC(plaintext, k) refers to the encryption of plaintext with a key k.</li>
        <li>KEK_i or CEK_i refers to the i-th instance of the KEK or CEK, respectively.</li>
      </ul>
      <section anchor="AES-KW">
        <name>Content Key Distribution with AES Key Wrap</name>
        <section anchor="introduction-1">
          <name>Introduction</name>
          <t>The AES Key Wrap (AES-KW) algorithm is described in RFC 3394 <xref target="RFC3394"/>, and
can be used to encrypt a randomly generated content-encryption key (CEK)
with a pre-shared key-encryption key (KEK). The COSE conventions for using
AES-KW are specified in Section 8.5.2 of <xref target="RFC9052"/> and in Section 6.2.1 of
<xref target="RFC9053"/>. The encrypted CEK is carried in the COSE_recipient structure
alongside the information needed for AES-KW. The COSE_recipient structure,
which is a substructure of the COSE_Encrypt structure, contains the CEK
encrypted by the KEK.</t>
          <t>The COSE_Encrypt structure conveys information for encrypting the payload,
which includes information like the algorithm and the IV, even though the
payload is not embedded in the COSE_Encrypt.ciphertext itself since it
conveyed as detached content.</t>
        </section>
        <section anchor="deployment-options">
          <name>Deployment Options</name>
          <t>There are three deployment options for use with AES Key Wrap for payload
encryption:</t>
          <ul spacing="normal">
            <li>If all authorized recipients have access to the KEK, a single
COSE_recipient structure contains the encrypted CEK. The sender executes
the following steps:</li>
          </ul>
          <artwork><![CDATA[
      Fetch KEK(*,S)
      Generate CEK
      ENC(CEK,KEK)
      ENC(payload,CEK)
]]></artwork>
          <ul spacing="normal">
            <li>If recipients have different KEKs, then multiple COSE_recipient structures
are included but only a single CEK is used. Each COSE_recipient structure
contains the CEK encrypted with the KEKs appropriate for a given recipient.
The benefit of this approach is that the payload is encrypted only once with
a CEK while there is no sharing of the KEK across recipients. Hence, authorized
recipients still use their individual KEK to decrypt the CEK and to subsequently
obtain the plaintext. The steps taken by the sender are:</li>
          </ul>
          <artwork><![CDATA[
      Generate CEK
      for i=1 to n {
         Fetch KEK_i(Ri, S)
         ENC(CEK, KEK_i)
      }
      ENC(payload,CEK)
]]></artwork>
          <ul spacing="normal">
            <li>The third option is to use different CEKs encrypted with KEKs of
authorized recipients. Assume there are n recipients with their unique KEKs -
KEK_1(R1, S),..., KEK_n(Rn, S). The sender needs to make the following steps:</li>
          </ul>
          <artwork><![CDATA[
      for i=1 to n {
         Fetch KEK_i(Ri, S)
         Generate CEK_i
         ENC(CEK_i, KEK_i)
         ENC(payload,CEK_i)
      }
]]></artwork>
          <t>This approach is appropriate when no benefits can be gained from encrypting
and transmitting payloads only once.</t>
        </section>
        <section anchor="cddl">
          <name>CDDL</name>
          <t>The CDDL for the COSE_Encrypt_Tagged structure is shown in <xref target="cddl-aeskw"/>.</t>
          <figure anchor="cddl-aeskw">
            <name>CDDL for AES-KW-based Content Key Distribution</name>
            <artwork><![CDATA[
COSE_Encrypt_Tagged = #6.96(COSE_Encrypt)
 
SUIT_Encryption_Info = COSE_Encrypt_Tagged

COSE_Encrypt = [
  protected   : bstr .cbor outer_header_map_protected,
  unprotected : outer_header_map_unprotected,
  ciphertext  : bstr / nil,
  recipients  : [ + COSE_recipient ]
]

outer_header_map_protected =
{
    1 => int,         ; algorithm identifier
  * label => values   ; extension point
}

outer_header_map_unprotected = 
{
    5 => bstr,        ; IV
  * label => values   ; extension point
}

COSE_recipient = [
  protected   : bstr .size 0,
  unprotected : recipient_header_map,
  ciphertext  : bstr        ; CEK encrypted with KEK
]

recipient_header_map = 
{
    1 => int,         ; algorithm identifier
    4 => bstr,        ; key identifier
  * label => values   ; extension point
}
]]></artwork>
          </figure>
          <t>Note that the AES-KW algorithm, as defined in Section 2.2.3.1 of <xref target="RFC3394"/>,
does not have public parameters that vary on a per-invocation basis. Hence,
the protected header in the COSE_recipient structure is a byte string
of zero length.</t>
          <t>The COSE specification requires a consistent byte stream for the authenticated
data structure to be created. This structure is shown in <xref target="cddl-enc-aeskw"/>.</t>
          <figure anchor="cddl-enc-aeskw">
            <name>CDDL for Enc_structure Data Structure</name>
            <artwork><![CDATA[
       Enc_structure = [
         context : "Encrypt",
         protected : empty_or_serialized_map,
         external_aad : bstr
       ]
]]></artwork>
          </figure>
          <t>This Enc_structure needs to be populated as follows:</t>
          <t>The protected field in the Enc_structure from <xref target="cddl-enc-aeskw"/> refers
to the content of the protected field from the COSE_Encrypt structure.
It is important to note that there are two protected fields shown
in <xref target="cddl-aeskw"/>:</t>
          <ul spacing="normal">
            <li>one in the COSE_Encrypt structure, and</li>
            <li>a second one in the COSE_recipient structure.</li>
          </ul>
          <t>The value of the external_aad MUST be set to a null value (major type 7,
value 22).</t>
        </section>
        <section anchor="example">
          <name>Example</name>
          <t>This example uses the following parameters:</t>
          <ul spacing="normal">
            <li>Algorithm for payload encryption: AES-GCM-128</li>
            <li>Algorithm id for key wrap: A128KW</li>
            <li>IV: 0x26, 0x68, 0x23, 0x06, 0xd4, 0xfb, 0x28, 0xca, 0x01, 0xb4, 0x3b, 0x80</li>
            <li>KEK: "aaaaaaaaaaaaaaaa"</li>
            <li>KID: "kid-1"</li>
            <li>Plaintext firmware (txt): "This is a real firmware image."
(in hex): 546869732069732061207265616C206669726D7761726520696D6167652E</li>
          </ul>
          <t>The COSE_Encrypt structure, in hex format, is (with a line break inserted):</t>
          <artwork><![CDATA[
D8608443A10101A1054C26682306D4FB28CA01B43B80F68340A2012204456B69642D
315818AF09622B4F40F17930129D18D0CEA46F159C49E7F68B644D
]]></artwork>
          <t>The resulting COSE_Encrypt structure in a diagnostic format is shown in
<xref target="aeskw-example"/>.</t>
          <figure anchor="aeskw-example">
            <name>COSE_Encrypt Example for AES Key Wrap</name>
            <artwork><![CDATA[
96([
  / protected: / << {
    / alg / 1: 1 / AES-GCM-128 /
  } >>,
  / unprotected: / {
    / IV / 5: h'1de460e8b5b68d7222c0d6f20484d8ab'
  },
  / payload: / null / detached ciphertext /,
  / recipients: / [
    [
      / protected: / << {
      } >>,
      / unprotected: / {
        / alg / 1: -3 / A128KW /,
        / kid / 4: 'kid-1'
      },
      / payload: CEK encrypted with KEK /
      h'a86200e4754733e4c00fc08c6a72cc1996e129922eab504f'
    ]
  ]
])
]]></artwork>
          </figure>
          <t>The CEK, in hex format, was "4C805F1587D624ED5E0DBB7A7F7FA7EB".
The encrypted firmware (with a line feed added) was:</t>
          <artwork><![CDATA[
A8B6E61EF17FBAD1F1BF3235B3C64C06098EA512223260
F9425105F67F0FB6C92248AE289A025258F06C2AD70415
]]></artwork>
        </section>
      </section>
      <section anchor="ES-DH">
        <name>Content Key Distribution with Ephemeral-Static Diffie-Hellman</name>
        <section anchor="introduction-2">
          <name>Introduction</name>
          <t>Ephemeral-Static Diffie-Hellman (ES-DH) is a scheme that provides public key
encryption given a recipient's public key. There are multiple variants
of this scheme; this document re-uses the variant specified in Section 8.5.5
of <xref target="RFC9052"/>.</t>
          <t>The following two layer structure is used:</t>
          <ul spacing="normal">
            <li>Layer 0: Has a content encrypted with the CEK. The content may be detached.</li>
            <li>Layer 1: Uses the AES Key Wrap algorithm to encrypt a randomly generated
CEK with the KEK derived with ECDH Ephemeral-Static whereby the resulting symmetric
key is fed into the HKDF-based key derivation function.</li>
          </ul>
          <t>As a result, the two layers combine ECDH-ES with AES-KW and HKDF. An example is
given in <xref target="esdh-example"/>.</t>
        </section>
        <section anchor="deployment-options-1">
          <name>Deployment Options</name>
          <t>There are two deployment options with this approach. We assume that recipients
are always configured with a device-unique public / private key pair.</t>
          <ul spacing="normal">
            <li>A sender wants to transmit a payload to multiple recipients. All recipients
shall receive the same encrypted payload, i.e. the same CEK is used.
One COSE_recipient structure per recipient is used and it contains the
CEK encrypted with the KEK. To generate the KEK each COSE_recipient structure
contains a COSE_recipient_inner structure to carry the sender's emphemeral key
and an identifier for the recipients public key.</li>
          </ul>
          <t>The steps taken by the sender are:</t>
          <artwork><![CDATA[
      Generate CEK
      for i=1 to n {
         Generate KEK_i(Ri, S) using ES-DH
         ENC(CEK, KEK_i)
      }
      ENC(payload,CEK)
]]></artwork>
          <ul spacing="normal">
            <li>The alternative is to encrypt a payload with a different CEK for each
recipient. Assume there are KEK_1(R1, S),..., KEK_n(Rn, S) have been generated
for the different recipients using ES-DH. The following steps needs to be made
by the sender:</li>
          </ul>
          <artwork><![CDATA[
      for i=1 to n {
         Generate KEK_i(Ri, S) using ES-DH
         Generate CEK_i
         ENC(CEK_i, KEK_i)
         ENC(payload,CEK_i)
      }
]]></artwork>
          <t>This results in n-manifests. This approach is useful when payloads contain
information unique to a device. The encryption operation effectively becomes
ENC(payload_i,CEK_i).</t>
        </section>
        <section anchor="cddl-1">
          <name>CDDL</name>
          <t>The CDDL for the COSE_Encrypt_Tagged structure is shown in <xref target="cddl-esdh"/>.</t>
          <figure anchor="cddl-esdh">
            <name>CDDL for ES-DH-based Content Key Distribution</name>
            <artwork><![CDATA[
COSE_Encrypt_Tagged = #6.96(COSE_Encrypt)
 
SUIT_Encryption_Info = COSE_Encrypt_Tagged

COSE_Encrypt = [
  protected   : bstr .cbor outer_header_map_protected,
  unprotected : outer_header_map_unprotected,
  ciphertext  : bstr / nil,
  recipients  : [ + COSE_recipient ]
]

outer_header_map_protected =
{
    1 => int,         ; algorithm identifier
  * label => values   ; extension point
}

outer_header_map_unprotected = 
{
    5 => bstr,        ; IV
  * label => values   ; extension point
}

COSE_recipient = [
  protected   : bstr .cbor recipient_header_pr_map,
  unprotected : recipient_header_unpr_map,
  ciphertext  : bstr        ; CEK encrypted with KEK
]

recipient_header_pr_map = 
{
    1 => int,         ; algorithm identifier for key wrap
  * label => values   ; extension point
}

recipient_header_unpr_map = 
{
   -1 => COSE_Key,    ; ephemeral public key for the sender
    4 => bstr,        ; identifier of the recipient public key
  * label => values   ; extension point
}
]]></artwork>
          </figure>
        </section>
        <section anchor="context-information-structure">
          <name>Context Information Structure</name>
          <t>The context information structure is used to ensure that the derived keying material 
is "bound" to the context of the transaction. This specification re-uses the structure
defined in Section 5.2 of RFC 9053 and tailors it accordingly.</t>
          <t>The following information elements are bound to the context:</t>
          <ul spacing="normal">
            <li>the hash of the public key of the sender,</li>
            <li>the hash of the public key of the recipient,</li>
            <li>the protocol employing the key-derivation method,</li>
            <li>information about the utilized algorithms
(including the payload encryption algorithms,
 the content key encryption algorithm,
 and the key length).</li>
          </ul>
          <t>The following fields in <xref target="cddl-context-info"/> require an explantation:</t>
          <ul spacing="normal">
            <li>The identity fields in the PartyInfoSender and the PartyInfoRecipient structures
contain the COSE_Key Thumbprint of the public keys of the sender and the recipient,
respectively. The details for computing these thumbprints are described in 
<xref target="I-D.isobe-cose-key-thumbprint"/>.</li>
            <li>The COSE_KDF_Context.AlgorithmID field contains the value found in the
alg field of the protected header in the COSE_Encrypt structure. This is the content
encryption algorithm identifier.</li>
            <li>The COSE_KDF_Context.SuppPubInfo.keyDataLength field contains the key length
of the algorithm in the alg field of the protected header in the COSE_Encrypt structure 
expressed as the number of bits.</li>
            <li>The COSE_KDF_Context.SuppPubInfo.other field captures the protocol in
which the ES-DH content key distribution algorithm is used and it is set to
the constant string "SUIT Payload Encryption".</li>
            <li>The COSE_KDF_Context.SuppPubInfo.protected field serializes the content 
of the recipient_header_pr_map field, which contains the content key distribution
algorithm identifier.</li>
          </ul>
          <figure anchor="cddl-context-info">
            <name>CDDL for COSE_KDF_Context Structure</name>
            <artwork><![CDATA[
PartyInfoSender = (
    identity : bstr,
    nonce : nil,
    other : bstr .size 0
)

PartyInfoRecipient = (
    identity : bstr,
    nonce : nil,
    other : bstr .size 0
)

COSE_KDF_Context = [
    AlgorithmID : int,
    PartyUInfo : [ PartyInfoSender ],
    PartyVInfo : [ PartyInfoRecipient ],
    SuppPubInfo : [
        keyDataLength : uint,
        protected : bstr .cbor recipient_header_pr_map,
        other: bstr "SUIT Payload Encryption"
    ],
    SuppPrivInfo : bstr .size 0
]
]]></artwork>
          </figure>
        </section>
        <section anchor="example-1">
          <name>Example</name>
          <t>This example uses the following parameters:</t>
          <ul spacing="normal">
            <li>Algorithm for payload encryption: AES-GCM-128</li>
            <li>IV: 0x26, 0x68, 0x23, 0x06, 0xd4, 0xfb,
    0x28, 0xca, 0x01, 0xb4, 0x3b, 0x80</li>
            <li>Algorithm for content key distribution: ECDH-ES + A128KW</li>
            <li>KID: "kid-1"</li>
            <li>Plaintext: "This is a real firmware image."</li>
            <li>Firmware (hex):
546869732069732061207265616C206669726D7761726520696D6167652E</li>
          </ul>
          <t>The COSE_Encrypt structure, in hex format, is (with a line break inserted):</t>
          <artwork><![CDATA[
D8608443A10101A1054C26682306D4FB28CA01B43B805823F21AC5881CD6FC45754
C65790F806C81A57B8D96C1988233BF40F670172405B5F107FD8444A101381C44A1
01381CA220A401022001215820415A8ED270C4B1F10B0A2D42B28EE6028CE25D745
52CB4291A4069A2E989B0F6225820CCC9AAF60514B9420C80619A4FF068BC1D7762
5BA8C90200882F7D5B73659E7604456B69642D315818B37CCD582696E5E62E5D93A
555E9072687D6170B122322EE
]]></artwork>
          <t>The resulting COSE_Encrypt structure in a diagnostic format is shown in 
<xref target="esdh-example"/>.</t>
          <figure anchor="esdh-example">
            <name>COSE_Encrypt Example for ES-DH</name>
            <artwork><![CDATA[
96(
  [
   / protected / h'a10101' / {
       \ alg \ 1:1 \ AES-GCM-128 \
     } / ,
   / unprotected / {
     / iv / 5:h'26682306D4FB28CA01B43B80'
     },
   / encrypted firmware /
    h'F21AC5881CD6FC45754C65790F806C81A57
      B8D96C1988233BF40F670172405B5F107FD',
    [
       / protected / h'A101381C' / {
           \ alg \ 1:-29 \ ECDH-ES + A128KW \
         } / ,
         h'A101381C',
       / unprotected / {
             / ephemeral / -1: {
                   / kty / 1:2,
                   / crv / -1:1,
                   / x / -2:h'415A8ED270C4B1F10B0A2D42B28EE602
                              8CE25D74552CB4291A4069A2E989B0F6',
                   / y / -3:h'CCC9AAF60514B9420C80619A4FF068BC
                              1D77625BA8C90200882F7D5B73659E76'
                 },
                 / kid / 4:'kid-1'
        },
        / ciphertext - CEK encrypted with KEK /
        h'B37CCD582696E5E62E5D93A555E9072687D6170B122322EE'
    ]
  ]
)
]]></artwork>
          </figure>
        </section>
      </section>
    </section>
    <section anchor="firmware-updates-on-iot-devices-with-flash-memory">
      <name>Firmware Updates on IoT Devices with Flash Memory</name>
      <t>Flash memory on microcontrollers is a type of non-volatile memory that erases
data in units called blocks, pages or sectors and re-writes data at byte level
(often 4-bytes).
Flash memory is furthermore segmented into different memory regions, which store
the bootloader, different versions of firmware images (in so-called slots),
and configuration data. <xref target="image-layout"/> shows an example layout of a
microcontroller flash area. The primary slot contains the firmware image to be
executed by the bootloader, which is a common deployment on devices that do
not offer the concept of position independent code.</t>
      <t>When the encrypted firmware image has been transferred to the device, it will
typically be stored in a staging area, in the secondary slot in our example.</t>
      <t>At the next boot, the bootloader will recognize a new firmware image in the
secondary slot and will start decrypting the downloaded image sector-by-sector
and will swap it with the image found in the primary slot.</t>
      <t>The swap should only take place after the signature on the plaintext is verified.
Note that the plaintext firmware image is available in the primary slot only after
the swap has been completed, unless "dummy decrypt" is used to compute the hash
over the plaintext prior to executing the decrypt operation during a swap.
Dummy decryption here refers to the decryption of the firmware image found in
the secondary slot sector-by-sector and computing a rolling hash over the resulting
plaintext firmware image (also sector-by-sector) without performing the swap operation.
While there are performance optimizations possible, such as conveying hashes for
each sector in the manifest rather than a hash of the entire firmware image,
such optimizations are not described in this specification.</t>
      <t>This approach of swapping the newly downloaded image with the previously valid
image is often referred as A/B approach. A/B refers to the two slots involved.
Two slots are used to allow the update to be reversed in case the newly obtained
firmware image fails to boot. This approach adds robustness to the firmware
update procedure.</t>
      <t>Since the image in primary slot is available in cleartext it may need to
re-encrypted it before copying it to the secondary slot. This may be necessary
when the secondary slot has different access permissions or when the staging
area is located in an off-chip flash memory and therefore more vulnerable to
physical attacks. Note that this description assumes that the processor does
not execute encrypted memory (i.e. using on-the-fly decryption in hardware).</t>
      <figure anchor="image-layout">
        <name>Example Flash Area Layout</name>
        <artwork><![CDATA[
+--------------------------------------------------+
| Bootloader                                       |
+--------------------------------------------------+
| Primary Slot                                     |
|                                        (sector 1)|
|..................................................|
|                                                  |
|                                        (sector 2)|
|..................................................|
|                                                  |
|                                        (sector 3)|
|..................................................|
|                                                  |
|                                        (sector 4)|
+--------------------------------------------------+
| Secondary Slot                                   |
|                                        (sector 1)|
|..................................................|
|                                                  |
|                                        (sector 2)|
|..................................................|
|                                                  |
|                                        (sector 3)|
|..................................................|
|                                                  |
|                                        (sector 4)|
+--------------------------------------------------+
| Swap Area                                        |
|                                                  |
+--------------------------------------------------+
| Configuration Data                               |
+--------------------------------------------------+
]]></artwork>
      </figure>
      <t>The ability to restart an interrupted firmware update is often a requirement
for low-end IoT devices. To fulfill this requirement it is necessary to chunk
a firmware image into sectors and to encrypt each sector individually
using a cipher that does not increase the size of the resulting ciphertext
(i.e., by not adding an authentication tag after each encrypted block).</t>
      <t>When an update gets aborted while the bootloader is decrypting the newly obtained
image and swapping the sectors, the bootloader can restart where it left off. This
technique offers robustness and better performance.</t>
      <t>For this purpose ciphers without integrity protection are used to encrypt the
firmware image. Integrity protection for the firmware image must, however, be
provided and the suit-parameter-image-digest, defined in Section 8.4.8.6 of
<xref target="I-D.ietf-suit-manifest"/>, MUST be used.</t>
      <t><xref target="I-D.ietf-cose-aes-ctr-and-cbc"/> registers AES Counter mode (AES-CTR) and
AES Cipher Block Chaining (AES-CBC) ciphers that do not offer integrity protection.
These ciphers are useful for the use cases that require firmware encryption on IoT
devices. For many other use cases where software packages, configuration information
or personalization data needs to be encrypted, the use of Authenticated Encryption
with Additional Data (AEAD) ciphers is preferred.</t>
      <t>The following sub-sections provide further information about the initialization vector
(IV) selection for use with AES-CBC and AES-CTR in the firmware encryption context. An
IV MUST NOTE be re-used when the same key is used. For this application, the IVs are
not random but rather based on the slot/sector-combination in flash memory. The
text below assumes that the block-size of AES is (much) smaller than sector size. The
typical sector-size of flash memory is in the order of KiB. Hence, multiple AES blocks
need to be decrypted until an entire sector is completed.</t>
      <section anchor="aes-cbc">
        <name>AES-CBC</name>
        <t>In AES-CBC a single IV is used for encryption of firmware belonging to a single sector
since individual AES blocks are chained toghether, as shown in <xref target="aes-cbc-fig"/>. The
numbering  of sectors in a slot MUST start with zero (0) and MUST increase by one with
every sector till the end of the slot is reached. The IV follows this numbering.</t>
        <t>For example, let us assume the slot size of a specific flash controller on an IoT device
is 64 KiB, the sector size 4096 bytes (4 KiB) and AES-128-CBC uses an AES-block size of
128 bit (16 bytes). Hence, sector 0 needs 4096/16=256 AES-128-CBC operations using IV 0.
If the firmware image fills the entire slot then that slot contains 16 sectors, i.e. IVs
ranging from 0 to 15.</t>
        <figure anchor="aes-cbc-fig">
          <name>AES-CBC Operation</name>
          <artwork><![CDATA[
       P1              P2
        |              |
   IV--(+)    +-------(+)
        |     |        |
        |     |        |
    +-------+ |    +-------+
    |       | |    |       |
    |       | |    |       |
 k--|  E    | | k--|  E    |
    |       | |    |       |
    +-------+ |    +-------+
        |     |        |
        +-----+        |
        |              |
        |              |
        C1             C2

Legend: 
  Pi = Plaintext blocks
  Ci = Ciphertext blocks
  E = Encryption function
  k = Symmetric key
  (+) = XOR operation
]]></artwork>
        </figure>
      </section>
      <section anchor="aes-ctr">
        <name>AES-CTR</name>
        <t>Unlike AES-CBC, AES-CTR uses an IV per AES operation, as shown in <xref target="aes-ctr-fig"/>.
Hence, when an image is encrypted using AES-CTR-128 or AES-CTR-256, the IV MUST
start with zero (0) and MUST be incremented by one for each 16-byte plaintext block
within the entire slot.</t>
        <t>Using the previous example with a slot size of 64 KiB, the sector size 4096 bytes and
the AES plaintext block size of 16 byte requires IVs from 0 to 255 in the first sector
and 16 * 256 IVs for the remaining sectors in the slot.</t>
        <figure anchor="aes-ctr-fig">
          <name>AES-CTR Operation</name>
          <artwork><![CDATA[
         IV1            IV2
          |              |
          |              |
          |              |
      +-------+      +-------+
      |       |      |       |
      |       |      |       |
   k--|  E    |   k--|  E    |
      |       |      |       |
      +-------+      +-------+
          |              |
     P1--(+)        P2--(+)
          |              |
          |              |
          C1             C2

Legend: 
  See previous diagram.
]]></artwork>
        </figure>
      </section>
    </section>
    <section anchor="complete-examples">
      <name>Complete Examples</name>
      <t>The following manifests examplify how to deliver encrypted firmware and its
encryption info to devices.</t>
      <t>The examples are signed using the following ECDSA secp256r1 key:</t>
      <artwork><![CDATA[
-----BEGIN PRIVATE KEY-----
MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgApZYjZCUGLM50VBC
CjYStX+09jGmnyJPrpDLTz/hiXOhRANCAASEloEarguqq9JhVxie7NomvqqL8Rtv
P+bitWWchdvArTsfKktsCYExwKNtrNHXi9OB3N+wnAUtszmR23M4tKiW
-----END PRIVATE KEY-----
]]></artwork>
      <t>The corresponding public key can be used to verify these examples:</t>
      <artwork><![CDATA[
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEhJaBGq4LqqvSYVcYnuzaJr6qi/Eb
bz/m4rVlnIXbwK07HypLbAmBMcCjbazR14vTgdzfsJwFLbM5kdtzOLSolg==
-----END PUBLIC KEY-----
]]></artwork>
      <t>Each example uses SHA-256 as the digest function.</t>
      <section anchor="example-AES-KW-write">
        <name>AES Key Wrap Example with Write Directive</name>
        <t>The following SUIT manifest requests a parser to write and to decrypt the
encrypted payload into a component with the suit-directive-write
directive.</t>
        <t>The SUIT manifest in diagnostic notation (with line breaks added
for readability) is shown here:</t>
        <artwork><![CDATA[
{::include examples/suit-manifest-aes-kw-content.diag.signed}
]]></artwork>
        <t>In hex format, the SUIT manifest is this:</t>
        <artwork><![CDATA[
{::include examples/suit-manifest-aes-kw-content.hex.signed}
]]></artwork>
      </section>
      <section anchor="example-AES-KW-copy">
        <name>AES Key Wrap Example with Fetch + Copy Directives</name>
        <t>The following SUIT manifest requests a parser to fetch the encrypted
payload and to stores it. Then, the payload is decrypt and stored into
another component with the suit-directive-copy directive. This approach
works well on constrained devices with execute-in-place flash memory.</t>
        <t>The SUIT manifest in diagnostic notation (with line breaks added for
readability) is shown here:</t>
        <artwork><![CDATA[
{::include examples/suit-manifest-aes-kw.diag.signed}
]]></artwork>
        <t>In hex format, the SUIT manifest is this:</t>
        <artwork><![CDATA[
{::include examples/suit-manifest-aes-kw.hex.signed}
]]></artwork>
      </section>
    </section>
    <section anchor="sec-cons">
      <name>Security Considerations</name>
      <t>The algorithms described in this document assume that the party performing payload encryption</t>
      <ul spacing="normal">
        <li>shares a key-encryption key (KEK) with the recipient (for use with the AES Key Wrap scheme), or</li>
        <li>is in possession of the public key of the recipient (for use with ECDH-ES).</li>
      </ul>
      <t>Both cases require some upfront communication interaction. This interaction is likely provided by
an device management solution, as described in <xref target="RFC9019"/>.</t>
      <t>To provide high security for AES Key Wrap it is important that the KEK is of high entropy,
and that implementations protect the KEK from disclosure. Compromise of the KEK may result
in the disclosure of all key data protected with that KEK.</t>
      <t>Since the CEK is randomly generated, it must be ensured that the guidelines for random number
generation in <xref target="RFC8937"/> are followed.</t>
      <t>In some cases third party companies analyse binaries for known security vulnerabilities. With
encrypted payloads this type of analysis is prevented. Consequently, these third party
companies either need to be given access to the plaintext binary before encryption or they need
to become authorized recipients of the encrypted payloads. In either case, it is necessary to
explicitly consider those third parties in the software supply chain when such a binary analysis
is desired.</t>
    </section>
    <section anchor="iana-considerations">
      <name>IANA Considerations</name>
      <t>IANA is asked to add two values to the SUIT_Parameters registry established by 
<xref target="I-D.ietf-suit-manifest"/>.</t>
      <artwork><![CDATA[
Label      Name                 Reference
-----------------------------------------
TBD1       Encryption Info      Section 4
]]></artwork>
      <t>[Editor's Note: 
 - TBD1: Proposed 19
]</t>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner"/>
            <date month="March" year="1997"/>
            <abstract>
              <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC3394">
          <front>
            <title>Advanced Encryption Standard (AES) Key Wrap Algorithm</title>
            <author fullname="J. Schaad" initials="J." surname="Schaad"/>
            <author fullname="R. Housley" initials="R." surname="Housley"/>
            <date month="September" year="2002"/>
          </front>
          <seriesInfo name="RFC" value="3394"/>
          <seriesInfo name="DOI" value="10.17487/RFC3394"/>
        </reference>
        <reference anchor="RFC9052">
          <front>
            <title>CBOR Object Signing and Encryption (COSE): Structures and Process</title>
            <author fullname="J. Schaad" initials="J." surname="Schaad"/>
            <date month="August" year="2022"/>
            <abstract>
              <t>Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size. There is a need to be able to define basic security services for this data format. This document defines the CBOR Object Signing and Encryption (COSE) protocol. This specification describes how to create and process signatures, message authentication codes, and encryption using CBOR for serialization. This specification additionally describes how to represent cryptographic keys using CBOR.</t>
              <t>This document, along with RFC 9053, obsoletes RFC 8152.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="96"/>
          <seriesInfo name="RFC" value="9052"/>
          <seriesInfo name="DOI" value="10.17487/RFC9052"/>
        </reference>
        <reference anchor="RFC9053">
          <front>
            <title>CBOR Object Signing and Encryption (COSE): Initial Algorithms</title>
            <author fullname="J. Schaad" initials="J." surname="Schaad"/>
            <date month="August" year="2022"/>
            <abstract>
              <t>Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size. There is a need to be able to define basic security services for this data format. This document defines a set of algorithms that can be used with the CBOR Object Signing and Encryption (COSE) protocol (RFC 9052).</t>
              <t>This document, along with RFC 9052, obsoletes RFC 8152.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9053"/>
          <seriesInfo name="DOI" value="10.17487/RFC9053"/>
        </reference>
        <reference anchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <date month="May" year="2017"/>
            <abstract>
              <t>RFC 2119 specifies common key words that may be used in protocol specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="I-D.ietf-suit-manifest">
          <front>
            <title>A Concise Binary Object Representation (CBOR)-based Serialization Format for the Software Updates for Internet of Things (SUIT) Manifest</title>
            <author fullname="Brendan Moran" initials="B." surname="Moran">
              <organization>Arm Limited</organization>
            </author>
            <author fullname="Hannes Tschofenig" initials="H." surname="Tschofenig">
              <organization>Arm Limited</organization>
            </author>
            <author fullname="Henk Birkholz" initials="H." surname="Birkholz">
              <organization>Fraunhofer SIT</organization>
            </author>
            <author fullname="Koen Zandberg" initials="K." surname="Zandberg">
              <organization>Inria</organization>
            </author>
            <author fullname="Ãyvind RÃ¸nningstad" initials="O." surname="RÃ¸nningstad">
              <organization>Nordic Semiconductor</organization>
            </author>
            <date day="27" month="February" year="2023"/>
            <abstract>
              <t>   This specification describes the format of a manifest.  A manifest is
   a bundle of metadata about code/data obtained by a recipient (chiefly
   the firmware for an IoT device), where to find the that code/data,
   the devices to which it applies, and cryptographic information
   protecting the manifest.  Software updates and Trusted Invocation
   both tend to use sequences of common operations, so the manifest
   encodes those sequences of operations, rather than declaring the
   metadata.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-suit-manifest-22"/>
        </reference>
        <reference anchor="I-D.ietf-cose-aes-ctr-and-cbc">
          <front>
            <title>CBOR Object Signing and Encryption (COSE): AES-CTR and AES-CBC</title>
            <author fullname="Russ Housley" initials="R." surname="Housley">
              <organization>Vigil Security, LLC</organization>
            </author>
            <author fullname="Hannes Tschofenig" initials="H." surname="Tschofenig">
              <organization>Arm Limited</organization>
            </author>
            <date day="25" month="May" year="2023"/>
            <abstract>
              <t>   The Concise Binary Object Representation (CBOR) data format is
   designed for small code size and small message size.  CBOR Object
   Signing and Encryption (COSE) is specified in RFC 9052 to provide
   basic security services using the CBOR data format.  This document
   specifies the conventions for using AES-CTR and AES-CBC as Content
   Encryption algorithms with COSE.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-cose-aes-ctr-and-cbc-06"/>
        </reference>
        <reference anchor="I-D.isobe-cose-key-thumbprint">
          <front>
            <title>COSE Key Thumbprint</title>
            <author fullname="Kohei Isobe" initials="K." surname="Isobe">
              <organization>SECOM CO., LTD.</organization>
            </author>
            <author fullname="Hannes Tschofenig" initials="H." surname="Tschofenig">
         </author>
            <date day="16" month="June" year="2023"/>
            <abstract>
              <t>   This specification defines a method for computing a hash value over a
   COSE Key. It defines which fields in a COSE Key structure are used in
   the hash computation, the method of creating a canonical form of the
   fields, and how to hash the byte sequence.  The resulting hash value
   can be used for identifying or selecting a key that is the subject of
   the thumbprint.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-isobe-cose-key-thumbprint-02"/>
        </reference>
      </references>
      <references>
        <name>Informative References</name>
        <reference anchor="RFC9019">
          <front>
            <title>A Firmware Update Architecture for Internet of Things</title>
            <author fullname="B. Moran" initials="B." surname="Moran"/>
            <author fullname="H. Tschofenig" initials="H." surname="Tschofenig"/>
            <author fullname="D. Brown" initials="D." surname="Brown"/>
            <author fullname="M. Meriac" initials="M." surname="Meriac"/>
            <date month="April" year="2021"/>
            <abstract>
              <t>Vulnerabilities in Internet of Things (IoT) devices have raised the need for a reliable and secure firmware update mechanism suitable for devices with resource constraints. Incorporating such an update mechanism is a fundamental requirement for fixing vulnerabilities, but it also enables other important capabilities such as updating configuration settings and adding new functionality.</t>
              <t>In addition to the definition of terminology and an architecture, this document provides the motivation for the standardization of a manifest format as a transport-agnostic means for describing and protecting firmware updates.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9019"/>
          <seriesInfo name="DOI" value="10.17487/RFC9019"/>
        </reference>
        <reference anchor="RFC9124">
          <front>
            <title>A Manifest Information Model for Firmware Updates in Internet of Things (IoT) Devices</title>
            <author fullname="B. Moran" initials="B." surname="Moran"/>
            <author fullname="H. Tschofenig" initials="H." surname="Tschofenig"/>
            <author fullname="H. Birkholz" initials="H." surname="Birkholz"/>
            <date month="January" year="2022"/>
            <abstract>
              <t>Vulnerabilities with Internet of Things (IoT) devices have raised the need for a reliable and secure firmware update mechanism that is also suitable for constrained devices. Ensuring that devices function and remain secure over their service lifetime requires such an update mechanism to fix vulnerabilities, update configuration settings, and add new functionality.</t>
              <t>One component of such a firmware update is a concise and machine-processable metadata document, or manifest, that describes the firmware image(s) and offers appropriate protection. This document describes the information that must be present in the manifest.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9124"/>
          <seriesInfo name="DOI" value="10.17487/RFC9124"/>
        </reference>
        <reference anchor="RFC8937">
          <front>
            <title>Randomness Improvements for Security Protocols</title>
            <author fullname="C. Cremers" initials="C." surname="Cremers"/>
            <author fullname="L. Garratt" initials="L." surname="Garratt"/>
            <author fullname="S. Smyshlyaev" initials="S." surname="Smyshlyaev"/>
            <author fullname="N. Sullivan" initials="N." surname="Sullivan"/>
            <author fullname="C. Wood" initials="C." surname="Wood"/>
            <date month="October" year="2020"/>
            <abstract>
              <t>Randomness is a crucial ingredient for Transport Layer Security (TLS) and related security protocols. Weak or predictable "cryptographically secure" pseudorandom number generators (CSPRNGs) can be abused or exploited for malicious purposes. An initial entropy source that seeds a CSPRNG might be weak or broken as well, which can also lead to critical and systemic security problems. This document describes a way for security protocol implementations to augment their CSPRNGs using long-term private keys. This improves randomness from broken or otherwise subverted CSPRNGs.</t>
              <t>This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8937"/>
          <seriesInfo name="DOI" value="10.17487/RFC8937"/>
        </reference>
        <reference anchor="RFC5652">
          <front>
            <title>Cryptographic Message Syntax (CMS)</title>
            <author fullname="R. Housley" initials="R." surname="Housley"/>
            <date month="September" year="2009"/>
            <abstract>
              <t>This document describes the Cryptographic Message Syntax (CMS).  This syntax is used to digitally sign, digest, authenticate, or encrypt arbitrary message content. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="70"/>
          <seriesInfo name="RFC" value="5652"/>
          <seriesInfo name="DOI" value="10.17487/RFC5652"/>
        </reference>
        <reference anchor="RFC5280">
          <front>
            <title>Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</title>
            <author fullname="D. Cooper" initials="D." surname="Cooper"/>
            <author fullname="S. Santesson" initials="S." surname="Santesson"/>
            <author fullname="S. Farrell" initials="S." surname="Farrell"/>
            <author fullname="S. Boeyen" initials="S." surname="Boeyen"/>
            <author fullname="R. Housley" initials="R." surname="Housley"/>
            <author fullname="W. Polk" initials="W." surname="Polk"/>
            <date month="May" year="2008"/>
            <abstract>
              <t>This memo profiles the X.509 v3 certificate and X.509 v2 certificate revocation list (CRL) for use in the Internet. An overview of this approach and model is provided as an introduction. The X.509 v3 certificate format is described in detail, with additional information regarding the format and semantics of Internet name forms. Standard certificate extensions are described and two Internet-specific extensions are defined. A set of required certificate extensions is specified. The X.509 v2 CRL format is described in detail along with standard and Internet-specific extensions. An algorithm for X.509 certification path validation is described. An ASN.1 module and examples are provided in the appendices. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5280"/>
          <seriesInfo name="DOI" value="10.17487/RFC5280"/>
        </reference>
        <reference anchor="iana-suit" target="TBD">
          <front>
            <title>IANA SUIT Manifest Registry</title>
            <author>
              <organization>Internet Assigned Numbers Authority</organization>
            </author>
            <date year="2023"/>
          </front>
        </reference>
        <reference anchor="ROP" target="https://en.wikipedia.org/wiki/Return-oriented_programming">
          <front>
            <title>Return-Oriented Programming</title>
            <author>
              <organization>Wikipedia</organization>
            </author>
            <date year="2023" month="March"/>
          </front>
        </reference>
      </references>
    </references>
    <?line 1041?>

<section anchor="acknowledgements">
      <name>Acknowledgements</name>
      <t>We would like to thank Henk Birkholz for his feedback on the CDDL description in this document.
Additionally, we would like to thank Michael Richardson, Ãyvind RÃ¸nningstad, Dave Thaler, Laurence
Lundblade, and Carsten Bormann for their review feedback. Finally, we would like to thank Dick Brooks for
making us aware of the challenges firmware encryption imposes on binary analysis.</t>
    </section>
  </back>
  <!-- ##markdown-source:
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

-->

</rfc>
